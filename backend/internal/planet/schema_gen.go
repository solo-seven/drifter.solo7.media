// Code generated by github.com/atombender/go-jsonschema, DO NOT EDIT.

package planet

import "encoding/json"
import "fmt"
import "reflect"

type Edge struct {
	// Id corresponds to the JSON schema field "id".
	Id int `json:"id" yaml:"id" mapstructure:"id"`

	// Vertices corresponds to the JSON schema field "vertices".
	Vertices []int `json:"vertices" yaml:"vertices" mapstructure:"vertices"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Edge) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["id"]; raw != nil && !ok {
		return fmt.Errorf("field id in Edge: required")
	}
	if _, ok := raw["vertices"]; raw != nil && !ok {
		return fmt.Errorf("field vertices in Edge: required")
	}
	type Plain Edge
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = Edge(plain)
	return nil
}

type Face struct {
	// Id corresponds to the JSON schema field "id".
	Id int `json:"id" yaml:"id" mapstructure:"id"`

	// Type corresponds to the JSON schema field "type".
	Type FaceType `json:"type" yaml:"type" mapstructure:"type"`

	// Vertices corresponds to the JSON schema field "vertices".
	Vertices []int `json:"vertices" yaml:"vertices" mapstructure:"vertices"`
}

type FaceType string

const FaceTypePentagon FaceType = "pentagon"
const FaceTypeTriangle FaceType = "triangle"

var enumValues_FaceType = []interface{}{
	"triangle",
	"pentagon",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *FaceType) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_FaceType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_FaceType, v)
	}
	*j = FaceType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Face) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["id"]; raw != nil && !ok {
		return fmt.Errorf("field id in Face: required")
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in Face: required")
	}
	if _, ok := raw["vertices"]; raw != nil && !ok {
		return fmt.Errorf("field vertices in Face: required")
	}
	type Plain Face
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = Face(plain)
	return nil
}

type Mesh struct {
	// Edges corresponds to the JSON schema field "edges".
	Edges []Edge `json:"edges" yaml:"edges" mapstructure:"edges"`

	// Faces corresponds to the JSON schema field "faces".
	Faces []Face `json:"faces" yaml:"faces" mapstructure:"faces"`

	// Vertices corresponds to the JSON schema field "vertices".
	Vertices []Vertex `json:"vertices" yaml:"vertices" mapstructure:"vertices"`
}

type MeshMetadata struct {
	// EdgeCount corresponds to the JSON schema field "edgeCount".
	EdgeCount int `json:"edgeCount" yaml:"edgeCount" mapstructure:"edgeCount"`

	// FaceCount corresponds to the JSON schema field "faceCount".
	FaceCount int `json:"faceCount" yaml:"faceCount" mapstructure:"faceCount"`

	// Genus corresponds to the JSON schema field "genus".
	Genus int `json:"genus" yaml:"genus" mapstructure:"genus"`

	// VertexCount corresponds to the JSON schema field "vertexCount".
	VertexCount int `json:"vertexCount" yaml:"vertexCount" mapstructure:"vertexCount"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *MeshMetadata) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["edgeCount"]; raw != nil && !ok {
		return fmt.Errorf("field edgeCount in MeshMetadata: required")
	}
	if _, ok := raw["faceCount"]; raw != nil && !ok {
		return fmt.Errorf("field faceCount in MeshMetadata: required")
	}
	if _, ok := raw["genus"]; raw != nil && !ok {
		return fmt.Errorf("field genus in MeshMetadata: required")
	}
	if _, ok := raw["vertexCount"]; raw != nil && !ok {
		return fmt.Errorf("field vertexCount in MeshMetadata: required")
	}
	type Plain MeshMetadata
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = MeshMetadata(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Mesh) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["edges"]; raw != nil && !ok {
		return fmt.Errorf("field edges in Mesh: required")
	}
	if _, ok := raw["faces"]; raw != nil && !ok {
		return fmt.Errorf("field faces in Mesh: required")
	}
	if _, ok := raw["vertices"]; raw != nil && !ok {
		return fmt.Errorf("field vertices in Mesh: required")
	}
	type Plain Mesh
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = Mesh(plain)
	return nil
}

type PlanetSchemaJson struct {
	// Mesh corresponds to the JSON schema field "mesh".
	Mesh Mesh `json:"mesh" yaml:"mesh" mapstructure:"mesh"`

	// Metadata corresponds to the JSON schema field "metadata".
	Metadata MeshMetadata `json:"metadata" yaml:"metadata" mapstructure:"metadata"`

	// PlanetId corresponds to the JSON schema field "planetId".
	PlanetId string `json:"planetId" yaml:"planetId" mapstructure:"planetId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PlanetSchemaJson) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["mesh"]; raw != nil && !ok {
		return fmt.Errorf("field mesh in PlanetSchemaJson: required")
	}
	if _, ok := raw["metadata"]; raw != nil && !ok {
		return fmt.Errorf("field metadata in PlanetSchemaJson: required")
	}
	if _, ok := raw["planetId"]; raw != nil && !ok {
		return fmt.Errorf("field planetId in PlanetSchemaJson: required")
	}
	type Plain PlanetSchemaJson
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = PlanetSchemaJson(plain)
	return nil
}

type Vertex struct {
	// Id corresponds to the JSON schema field "id".
	Id int `json:"id" yaml:"id" mapstructure:"id"`

	// X corresponds to the JSON schema field "x".
	X float64 `json:"x" yaml:"x" mapstructure:"x"`

	// Y corresponds to the JSON schema field "y".
	Y float64 `json:"y" yaml:"y" mapstructure:"y"`

	// Z corresponds to the JSON schema field "z".
	Z float64 `json:"z" yaml:"z" mapstructure:"z"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Vertex) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["id"]; raw != nil && !ok {
		return fmt.Errorf("field id in Vertex: required")
	}
	if _, ok := raw["x"]; raw != nil && !ok {
		return fmt.Errorf("field x in Vertex: required")
	}
	if _, ok := raw["y"]; raw != nil && !ok {
		return fmt.Errorf("field y in Vertex: required")
	}
	if _, ok := raw["z"]; raw != nil && !ok {
		return fmt.Errorf("field z in Vertex: required")
	}
	type Plain Vertex
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = Vertex(plain)
	return nil
}
